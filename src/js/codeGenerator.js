// Copyright 2016 by Prahlad Yeri
// Copyright 2020 by Andr√© Kreienbring
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 3 as published by
// the Free Software Foundation.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

import {Logger} from "./js-log.js";
import {utils} from "./utils.js";

const logger = Logger.getClassLogger("codeGenerator");


/**
*	Used to generate the code for various DB or ORM Systems.
*	Every specific codegenerator is organized in it's on class.
* 	This class holds methods which are common support utilities for all of them.	
*/
class CodeGenerator {
	 constructor() {
		this.codeGenerators = {
			"ORM/SQLAlchemy": new ORMSQLAlchemy(),
			"MySQL / PostgreSQL": new MySQL(),
			"SQLite": new SQLite(),
			"Liferay Service Builder": new LiferayServiceBuilder()
		};
	 };	
	 
	 /**
	 * After a generator was selected, finally generates the code, inserts
	 * it into the corresponding template and shows the result window.
	 * @param outputType the selected code generator
	 * @param additionalOptions may contain values set by the user in the code generator popup
	 * 		that was created by showResultsDialog 
	 */
	 generateCode(outputType, additionalOptions) {

		// Pick code generator based on desired output format
		const selectedCodeGenerator = this.codeGenerators[outputType];
		selectedCodeGenerator.options = additionalOptions;
		
		// Combine template with generated code then show the output
		jQuery.get(dbdesigner.context + "assets/templates/" + selectedCodeGenerator.template, (data) => {
			let code = selectedCodeGenerator.generateCode();
			code = data.format({body: code, version: dbdesigner.version});
			this.showResults(code);
		});
	 };
	 
	 /**
	 * showResultsDialog is called when the user wants to generate code. 
	 * In the popup the code generator is selected and code generation is started.
	 * @see dbdesigner.showResultsDialog()
	 */
	 showResultsDialog(){
		if (Object.keys(dbdesigner.tables).length==0) {
			utils.bspopup("There should be at least one table");
			return;
		};
		
		//create the HTML object that will be evaluated by utils.bspopup. Most important part 
		//is the call back function that is triggerd on change. If triggered it calls
		//the handleOptionsRequest method of the corresponding generator.
		const htmlObj = {};
		htmlObj.elements = [{
			result:"outputType", 
			type:"select", 
			text:"Select output format", 
			list:Object.keys(this.codeGenerators),
			onChange: function(event){
				logger.debug("HTML Request for " + this.value + " received");
		    	const $form = jQuery(this).closest("form")
		    	
				//clear the existing additional form fields and let the corresponding code generator handle it.
		    	$form.find("#additionalOptions").remove();
				codeGenerator.codeGenerators[this.value].handleOptionsRequest($form);
			}
		}];
		
		//open the popup with the select element that lets the user select a generator
		//also a function is passed that is called if the user clicks the passed button.
		//if the OK button is clicked the option values, that were injected by a generator, are
		//available in the passed data element.
		utils.bspopup({
			title:"Code Generator",
			type:"form",
			htmlObj: htmlObj, 
			button1: {text: "Ok", type: "btn-primary"},
			success: (data) => {
				const outputType = data.outputType.value;
				let additionalOptions = {};
				if(data.additionalOptions) additionalOptions = data.additionalOptions;
				this.generateCode(outputType, additionalOptions);
			}
		});
	 };
	 
	/**
	 * Shows a modal window with the code that was generated by a codeGenerator
	 * @param code the code that was generated
	 */
	showResults(code) {
		if (jQuery(dbdesigner.namespaceWrapper + "#resultsDialog").length==0) {
			logger.log('resultsDialog not found in cache');
			jQuery(dbdesigner.namespaceWrapper + "#holderResults").load(dbdesigner.context + "assets/partials/resultsDialog.html?time=" + (new Date()).getTime(), (data) =>{
				logger.log("resultsDialog loaded.");
				
				jQuery(dbdesigner.namespaceWrapper + "#resultsDialog").on('shown.bs.modal', function(e) {
					logger.log("ResultsDialog is shown");
				});
				
				this.showResults(code);
			});
			return;
		};
		
		jQuery(dbdesigner.namespaceWrapper + "#resultsDialog #theCode").empty();
		jQuery(dbdesigner.namespaceWrapper + "#resultsDialog #theCode").append('<pre class="prettyprint"></pre>');
		jQuery(dbdesigner.namespaceWrapper + "#resultsDialog #theCode pre").text(code);
		jQuery(dbdesigner.namespaceWrapper + "#resultsDialog").modal();
	};
		
	 
}; //class CodeGenerator

/**
 * LiferayServiceBuilder is a code generator that creates the service.xml code.
 * This xml can be used by Liferay developers to create service interfaces and an object relational mapping. 
 */
class LiferayServiceBuilder{
    constructor() {
    	this.template = "service.tpl";
    	this.rawTypes = {"Text": "String", "Integer": "int","Float": "float", "Date": "Date", "DateTime": "Date"};
    	//create generator specific options, that will be set CodeGenerator.generateCode()
    	//these are also used as defaults
    	this.options = {datasource:"indi-smart", datasourcetype:"external"};
     }
    
	/**
	 * Implement this method, if there are additional options that the code generator needs to generate the code
	 * This is a required interface method as it will be called by Codegenerator.showResultsDialog()
	 * Mark the elements with the class "additionalOption" to have there options returned to the generator.
	 * @param $form The (currently) visible popup where input elements for the options need to be inserted.
	 * @see CodeGenerator.showResultsDialog()
	 */
    handleOptionsRequest($form){
    	const optionsHTML = `<div id="additionalOptions">
    						<hr class="separator">
    						<p class="messageText">Please pass the following options:</p>
    						<input id="datasource" class="additionalOption form-control form-control-sm" type="text" placeholder="Data Source Name" value="${this.options.datasource}" maxlength="20"></input>
    						<select id="datasourcetype" class="additionalOption form-control form-control-sm">
    							<option value="external">External</option>"
    							<option value="internal">Internal</option>"
    						</div>
    						`
    	$form.append(optionsHTML);
    };

	/**
	 * Creates the XML of the service.xml
	 * This is a required interface method as it will be called by Codegenerator.generateCode()
	 * @see CodeGenerator.generateCode()
	 * @return The created XML.
	 */
	generateCode(){
		logger.debug("Options are " + JSON.stringify(this.options));
		
		let code = "";
		
		let allHavePrimaryKeys = true;
		jQuery.each(dbdesigner.tables, (tableId, table) => {
			let tableHasPrimaryKey = false;
			let externalTable = this.options.datasourcetype == "external" ? `table='${table.name}'` : "";
			code += `\t<entity data-source='${this.options.datasource}' name='${table.name}' local-service='true' cache-enabled='false' remote-service='false' ${externalTable}>\n`;
			
			jQuery.each(table.fields, (fieldId, field) => {
				tableHasPrimaryKey = tableHasPrimaryKey || field.primaryKey;
				let externalColumn = this.options.datasourcetype == "external" ? `db-name='${field.name}'` : "";
				code += `\t\t<column name='${field.name}' type='${this.rawTypes[field.type]}' ${externalColumn} ${field.primaryKey ? 'primary=\'true\'' : ''}/>\n`;
			});
			
			allHavePrimaryKeys	= allHavePrimaryKeys && tableHasPrimaryKey;
			code += "\t</entity>\n";
		});
		
		if(!allHavePrimaryKeys) utils.bsalert({text:"Liferay requires that all entities have a primary key.",type:"danger", delay: 0});

		return code;
	}
};

/**
 * ORMSQLAlchemy is an Python code Generator 
 */
class ORMSQLAlchemy{
    constructor() {
    	this.template = "sqlalchemy.py";
     	this.options = {};
     }
    
	/**
	 * Implement this method, if there are additional options that the code generator needs to generate the code
	 * This is a required interface method as it will be called by Codegenerator.showResultsDialog()
	 * Mark the elements with the class "additionalOption" to have there options returned to the generator.
	 * @param $form The (currently) visible popup where input elements for the options need to be inserted.
	 * @see CodeGenerator.showResultsDialog()
	 */
    handleOptionsRequest($form){
    	//noop
    };
    
	/**
	 * Creates Python code 
	 * This is a required interface method as it will be called by Codegenerator.generateCode()
	 * @see CodeGenerator.generateCode()
	 * @return The created Python code.
	 */
	generateCode(){
		let code = '';
		
		 jQuery.each(dbdesigner.tables, function(tableId, table) {
			code += "class " + table.name + "(Base):\n";
			code += "\t" + "__tablename__ = \"" + table.name + "\"\n";
			jQuery.each(table.fields, function(fieldId, field){
				//embed quotes if they don't already exist
				if (field.type=='Text' || field.type=='String') {
					if (field.defaultValue!=null) {
						var sdef = field.defaultValue;
						if (sdef.indexOf('"') !=0) field.defaultValue = '"' + sdef;
						if (sdef.lastIndexOf('"') != sdef.length-1 || sdef.lastIndexOf('"')==-1) field.defaultValue += '"';
					};
					// Default text size is 255 if user didn't specify a size
					if (field.size==0) {
						field.size = 255;
					};
				};
				
				code += "\t" + field.name + " = Column(" 
				+ field.type + (field.size==0 ? '' : '(' + field.size + ')')
				+ (field.pkRef != null ? ", ForeignKey('" + field.pkRef + "')" : "")
				+ (field.primaryKey ? ", primary_key=True" : "")
				+ (field.unique ? ", unique=True" : "")
				+ (field.notNull ? ", nullable=False" : "")
				+ (field.defaultValue!=null ? ", default=" + field.defaultValue : "")
				+ ")\n";
			});
			code += "\n";
		});

		return code;
	}
};

/**
 * MySQL is an internal SQL Generator. The generated SQL work also with PostgresSQL and probably MariaDB 
 */
class MySQL{
    constructor() {
    	this.template = "mysql.sql";
    	this.rawTypes = {"Text": "varchar", "Integer": "int","Float": "float", "Date": "date", "DateTime": "datetime"};
    	this.deferForeignKeys = true; // Add foreign key constraint after running CREATE TABLE statement?
    	this.options = {};
    }
    
	/**
	 * Implement this method, if there are additional options that the code generator needs to generate the code
	 * This is a required interface method as it will be called by Codegenerator.showResultsDialog()
	 * Mark the elements with the class "additionalOption" to have there options returned to the generator.
	 * @param $form The (currently) visible popup where input elements for the options need to be inserted.
	 * @see CodeGenerator.showResultsDialog()
	 */
    handleOptionsRequest($form){
    	//noop
    };
    
	/**
	 * Creates a primary / foreign key relation between two tables
	 * @param sourceTableName The table that is referenced by a primary key from another table
	 * @param sourceTableField The fields which are refrences by primary key fields in another table
	 * @param targetTableName The table that has the primary keys which are referencing the source table
	 * @param targetTableFields The primary field(s) in in the target table that are referencing the source table
	 * @return The alter table statement to create the primary / foreign key relation.
	 '
	 */
    generateFKConstraint (sourceTableName, sourceTableFields, targetTableName, targetTableFields) {
    	return "alter table " + sourceTableName + " add constraint fk_" + sourceTableName +  "_" + targetTableName 
    			+  " foreign key (" + sourceTableFields +  ") references " + targetTableName +  "(" + targetTableFields  + ");"
    }    
    
	/**
	 * Creates the SQL for MySQL / PostgreSQL
	 * This is a required interface method as it will be called by Codegenerator.generateCode()
	 * @see CodeGenerator.generateCode()
	 * @return The created SQL.
	 */
    generateCode(){
		let code = '';
		let constraints = [];

		jQuery.each(dbdesigner.tables, (tableId, table) => {
			logger.info("Generating Code for Table " + table.name);
			
			code += "create table " + table.name + "\n(\n";
			
			const primaryFields = [];
			let primaryCount = 0;
			let targetTable;
			let targetField;
			
			// Collect number and names of primary key and referenced fields
			jQuery.each(table.fields, function(fieldId, field) {
				if (field.primaryKey) {
					primaryFields.push(field.name);
					primaryCount += 1;
				};
			});
			
			let fieldCode = [];
			let referencedTables = [];
			
			//generate the table and field dfinitions
			jQuery.each(table.fields, (fieldId, field) =>
			{
				if (field.type=='Text' || field.type=='String') {
					//embed quotes if they don't already exist
					if (field.defaultValue!=null) {
						const sdef = field.defaultValue;
						if (sdef.indexOf('"') !=0) field.defaultValue = '"' + sdef;
						if (sdef.lastIndexOf('"') != sdef.length-1 || sdef.lastIndexOf('"')==-1) field.defaultValue += '"';
					}
					
					// Default text size is 255 if user didn't specify a size
					if (field.size==0) {
						field.size = 255;
					}
				}
				
				fieldCode.push("\t" + field.name + " " + this.rawTypes[field.type] + (field.size==0 ? '' : '(' + field.size + ')')
				+ (field.notNull ? " not null" : "")
				+ (field.primaryKey && primaryCount == 1 ? " primary key" : "")
				+ (field.unique ? " unique" : "")
				+ (field.defaultValue != null ? " default " + field.defaultValue  : ""));
				
				if (field.pkRef != null) 
				{
					
					targetTable = dbdesigner.tables[field.pkRef.split(".")[0]];
					targetField = targetTable.fields[field.pkRef.split(".")[1]];
					
					//push to generate composite references later
					logger.debug("Pushing [" + targetTable.name+ "." + targetField.name + "," + table.name + "." + field.name +"] to referencedTables");
					referencedTables.push([targetTable.name+ "." + targetField.name, table.name + "." + field.name]);
				};
				
			}); //for each field
			
			//now generate the constraints with respect to composite keys
			let targetTableName;
			let targetFieldName;
			let sourceTableName;
			let sourceFieldName;
			let sourceTableFields = "";
			let targetTableFields = "";
			let lastReferencedTable = "";
			let constraint = "";
			
			//sort the array to have references to the same table in sequence
			if(referencedTables.length > 0){
				referencedTables.sort(([a], [b]) => a < b ? -1 : a > b ? 1 : 0);
				logger.debug("sorted referencedTables = " + JSON.stringify(referencedTables));
				
				targetTableName = referencedTables[0][0].split(".")[0];
				targetFieldName = referencedTables[0][0].split(".")[1];
				sourceTableName = referencedTables[0][1].split(".")[0];
				sourceFieldName = referencedTables[0][1].split(".")[1];
				
				targetTableFields = targetFieldName;
				sourceTableFields = sourceFieldName;
				
				lastReferencedTable = targetTableName;
			}; 
			
			for (let i=1; i < referencedTables.length; i++){
				
				if (referencedTables[i][0].split(".")[0] == lastReferencedTable && referencedTables.length > 1){
				}else{
					if (targetTableFields == "") targetTableFields = targetFieldName;
					if (sourceTableFields == "") sourceTableFields = sourceFieldName;
					
					// add any constraints placed by raw formats like MySQL and PostgreSQL.
					// save constraints in an array (they are added after all tables have been created)
					constraint = this.generateFKConstraint(sourceTableName, sourceTableFields, targetTableName, targetTableFields);
					
					logger.debug("Adding constraint: " + constraint);
					constraints.push(constraint);
					targetTableFields = "";
					sourceTableFields = "";
				};
				
				targetTableName = referencedTables[i][0].split(".")[0];
				targetFieldName = referencedTables[i][0].split(".")[1];
				sourceTableName = referencedTables[i][1].split(".")[0];
				sourceFieldName = referencedTables[i][1].split(".")[1];
				
				if (targetTableFields != ""){
					targetTableFields += ", " + targetFieldName;
					sourceTableFields += ", " + sourceFieldName;
				}else{
					targetTableFields = targetFieldName;
					sourceTableFields = sourceFieldName;
				};
				
				lastReferencedTable = targetTableName;
			};
			
			//add the remaining constraints
			if (targetTableFields != ""){
				// add any constraints placed by raw formats like MySQL and PostgreSQL.
				// save constraints in an array (they are added after all tables have been created)
				constraint = this.generateFKConstraint(sourceTableName, sourceTableFields, targetTableName, targetTableFields);
				logger.debug("Adding constraint: " + constraint);
				constraints.push(constraint);
			};
				
			// Add multi-field primary key if needed
			if (primaryCount > 1) {
				fieldCode.push("\tprimary key (" + primaryFields.join(', ') + ")");
			}
			
			// Add foreign key lines now if needed
			if (!this.deferForeignKeys) {
				fieldCode = fieldCode.concat(constraints);
				constraints = [];
			}
			
			// Add all the lines for declaring fields, primary keys, and FKs (if needed)
			code += fieldCode.join(",\n")+"\n);\n";
			
		}); //for each table

		// If foreign keys have to come after everything else, add them here
		if (this.deferForeignKeys) {
			code += constraints.join("\n");
		};
	
		return code;
    }
};

/**
 * SQLite is an internal code Generator.
 * SQLite inherits from MySQL. It's mostly the same syntax, the only difference is that
 * MySQL doesn't support ALTER TABLE ADD CONSTRAINT FOREIGN KEY, so FKs have to be added
 * as part of the CREATE TABLE statement. 
 */
class SQLite extends MySQL{
	constructor(){
		
		super();
		this.template = "sqlite.sql";
		
		// Add foreign key constraint after running CREATE TABLE statement?
		this.deferForeignKeys = false;
		this.options = {};
	}
	
	/**
	 * Implement this method, if there are additional options that the code generator needs to generate the code
	 * This is a required interface method as it will be called by Codegenerator.showResultsDialog()
	 * Mark the elements with the class "additionalOption" to have there options returned to the generator.
	 * @param $form The (currently) visible popup where input elements for the options need to be inserted.
	 * @see CodeGenerator.showResultsDialog()
	 */
    handleOptionsRequest($form){
    	//noop
    };
    
	/**
	 * Creates a primary / foreign key relation between two tables
	 * @param sourceTableName The table that is referenced by a primary key from another table
	 * @param sourceTableField The fields which are refrences by primary key fields in another table
	 * @param targetTableName The table that has the primary keys which are referencing the source table
	 * @param targetTableFields The primary field(s) in in the target table that are referencing the source table
	 * @return The alter table statement to create the primary / foreign key relation.
	 '
	 */
	generateFKConstraint(firstTableName, firstTableFields, secondTableName, secondTableFields) {
		return "\tforeign key (" + firstTableFields +  ") references " + secondTableName +  "(" + secondTableFields  + ")"
	}
}; 

const codeGenerator = new CodeGenerator();
export {codeGenerator};